/**
 * Script to update token creation times for top tokens by market cap
 * Quick script to test the functionality on high-value tokens first
 */

import { db } from '../database';
import { TokenCreationTimeService } from '../services/token-creation-time-service';
import chalk from 'chalk';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

async function updateTopTokensCreationTimes() {
  console.log(chalk.cyan('🕐 Top Tokens Creation Time Update'));
  console.log(chalk.gray('=====================================\n'));
  
  const creationTimeService = TokenCreationTimeService.getInstance();
  
  try {
    // Get top 20 tokens by market cap that don't have creation time
    const tokensResult = await db.query(`
      SELECT mint_address, symbol, name, latest_market_cap_usd, graduated_to_amm
      FROM tokens_unified
      WHERE token_created_at IS NULL
        AND latest_market_cap_usd > 10000
      ORDER BY latest_market_cap_usd DESC NULLS LAST
      LIMIT 20
    `);
    
    const tokens = tokensResult.rows;
    console.log(chalk.yellow(`Processing top ${tokens.length} tokens by market cap\n`));
    
    if (tokens.length === 0) {
      console.log(chalk.green('✅ All top tokens already have creation times!'));
      return;
    }
    
    let successCount = 0;
    let failCount = 0;
    
    for (const token of tokens) {
      const displayName = token.symbol || token.name || 'Unknown';
      const marketCap = `$${Number(token.latest_market_cap_usd).toLocaleString()}`;
      const status = token.graduated_to_amm ? '🎓' : '🚀';
      
      console.log(chalk.blue(`\n${status} Processing: ${displayName}`));
      console.log(chalk.gray(`   Mint: ${token.mint_address}`));
      console.log(chalk.gray(`   Market Cap: ${marketCap}`));
      
      try {
        const creationInfo = await creationTimeService.getTokenCreationTime(token.mint_address);
        
        if (creationInfo) {
          await creationTimeService.updateTokenCreationTime(token.mint_address, creationInfo);
          
          const age = Date.now() - creationInfo.creationTime.getTime();
          const ageHours = Math.floor(age / (1000 * 60 * 60));
          const ageDays = Math.floor(ageHours / 24);
          const ageStr = ageDays > 0 ? `${ageDays}d ${ageHours % 24}h` : `${ageHours}h`;
          
          console.log(chalk.green(`   ✅ Created: ${creationInfo.creationTime.toLocaleString()}`));
          console.log(chalk.green(`   ✅ Age: ${ageStr}`));
          console.log(chalk.green(`   ✅ Source: ${creationInfo.source}`));
          if (creationInfo.creator) {
            console.log(chalk.green(`   ✅ Creator: ${creationInfo.creator}`));
          }
          successCount++;
        } else {
          console.log(chalk.yellow('   ⚠️  Creation time not found'));
          failCount++;
        }
      } catch (error) {
        console.log(chalk.red('   ❌ Error fetching creation time'));
        if (process.env.DEBUG) {
          console.error(error);
        }
        failCount++;
      }
      
      // Longer rate limiting to avoid 429 errors
      await new Promise(resolve => setTimeout(resolve, 2000)); // 2 seconds between tokens
    }
    
    // Summary
    console.log(chalk.cyan('\n====================================='));
    console.log(chalk.green(`✅ Successfully updated: ${successCount} tokens`));
    console.log(chalk.yellow(`⚠️  Failed: ${failCount} tokens`));
    console.log(chalk.cyan('====================================='));
    
  } catch (error) {
    console.error(chalk.red('\n❌ Script error:'), error);
    process.exit(1);
  } finally {
    // db.end() is not available with the current db module
    // The connection will be closed when the process exits
  }
}

// Run the script
updateTopTokensCreationTimes()
  .then(() => {
    console.log(chalk.green('\n✨ Done!'));
    process.exit(0);
  })
  .catch(error => {
    console.error(chalk.red('\n💥 Failed:'), error);
    process.exit(1);
  });