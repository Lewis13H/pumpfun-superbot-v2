/**
 * Script to update token creation times for all existing tokens
 * Fetches actual blockchain creation timestamps and updates the database
 */

import { db } from '../database';
import { TokenCreationTimeService } from '../services/token-creation-time-service';
import chalk from 'chalk';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

async function updateTokenCreationTimes() {
  console.log(chalk.cyan('üïê Token Creation Time Update Script'));
  console.log(chalk.gray('=====================================\n'));
  
  const creationTimeService = TokenCreationTimeService.getInstance();
  
  try {
    // Get all tokens that don't have creation time yet
    const tokensResult = await db.query(`
      SELECT mint_address, symbol, name, latest_market_cap_usd
      FROM tokens_unified
      WHERE token_created_at IS NULL
      ORDER BY latest_market_cap_usd DESC NULLS LAST
    `);
    
    const tokens = tokensResult.rows;
    console.log(chalk.yellow(`Found ${tokens.length} tokens without creation time\n`));
    
    if (tokens.length === 0) {
      console.log(chalk.green('‚úÖ All tokens already have creation times!'));
      return;
    }
    
    // Process in batches to avoid overwhelming the APIs
    const BATCH_SIZE = 10;
    const batches = [];
    
    for (let i = 0; i < tokens.length; i += BATCH_SIZE) {
      batches.push(tokens.slice(i, i + BATCH_SIZE));
    }
    
    console.log(chalk.gray(`Processing in ${batches.length} batches of ${BATCH_SIZE} tokens each...\n`));
    
    let totalUpdated = 0;
    let totalFailed = 0;
    
    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
      const batch = batches[batchIndex];
      console.log(chalk.blue(`\nBatch ${batchIndex + 1}/${batches.length}:`));
      
      for (const token of batch) {
        const displayName = token.symbol || token.name || 'Unknown';
        const marketCap = token.latest_market_cap_usd 
          ? `$${Number(token.latest_market_cap_usd).toLocaleString()}`
          : 'N/A';
        
        process.stdout.write(
          chalk.gray(`  ${token.mint_address.slice(0, 8)}... (${displayName}, ${marketCap}) ... `)
        );
        
        try {
          const creationInfo = await creationTimeService.getTokenCreationTime(token.mint_address);
          
          if (creationInfo) {
            await creationTimeService.updateTokenCreationTime(token.mint_address, creationInfo);
            console.log(chalk.green(`‚úÖ ${creationInfo.creationTime.toLocaleString()} (${creationInfo.source})`));
            totalUpdated++;
          } else {
            console.log(chalk.yellow('‚ö†Ô∏è  Not found'));
            totalFailed++;
          }
        } catch (error) {
          console.log(chalk.red('‚ùå Error'));
          totalFailed++;
          if (process.env.DEBUG) {
            console.error(error);
          }
        }
        
        // Rate limiting between requests
        await new Promise(resolve => setTimeout(resolve, 200));
      }
      
      // Longer delay between batches
      if (batchIndex < batches.length - 1) {
        console.log(chalk.gray('\nWaiting before next batch...'));
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
    
    // Final summary
    console.log(chalk.cyan('\n====================================='));
    console.log(chalk.green(`‚úÖ Successfully updated: ${totalUpdated} tokens`));
    console.log(chalk.yellow(`‚ö†Ô∏è  Failed/Not found: ${totalFailed} tokens`));
    console.log(chalk.cyan('=====================================\n'));
    
    // Show some statistics
    const statsResult = await db.query(`
      SELECT 
        COUNT(*) as total_tokens,
        COUNT(token_created_at) as tokens_with_creation_time,
        MIN(token_created_at) as oldest_token,
        MAX(token_created_at) as newest_token
      FROM tokens_unified
    `);
    
    const stats = statsResult.rows[0];
    const percentage = (stats.tokens_with_creation_time / stats.total_tokens * 100).toFixed(1);
    
    console.log(chalk.blue('üìä Database Statistics:'));
    console.log(chalk.gray(`   Total tokens: ${stats.total_tokens}`));
    console.log(chalk.gray(`   With creation time: ${stats.tokens_with_creation_time} (${percentage}%)`));
    if (stats.oldest_token) {
      console.log(chalk.gray(`   Oldest token: ${new Date(stats.oldest_token).toLocaleString()}`));
      console.log(chalk.gray(`   Newest token: ${new Date(stats.newest_token).toLocaleString()}`));
    }
    
  } catch (error) {
    console.error(chalk.red('\n‚ùå Script error:'), error);
    process.exit(1);
  } finally {
    // db.end() is not available with the current db module
    // The connection will be closed when the process exits
  }
}

// Run the script
updateTokenCreationTimes()
  .then(() => {
    console.log(chalk.green('\n‚ú® Script completed successfully!'));
    process.exit(0);
  })
  .catch(error => {
    console.error(chalk.red('\nüí• Script failed:'), error);
    process.exit(1);
  });