<!DOCTYPE html>
<html>
<head>
    <title>Pump.fun Monitor Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #111827;
            color: #f3f4f6;
            line-height: 1.6;
        }
        
        .header {
            background: #1f2937;
            padding: 20px;
            border-bottom: 1px solid #374151;
        }
        
        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .stats {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
        }
        
        .stat-label {
            font-size: 12px;
            color: #9ca3af;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #3b82f6;
        }
        
        .container {
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .filters input,
        .filters select,
        .filters button {
            padding: 8px 16px;
            background: #1f2937;
            border: 1px solid #374151;
            color: #f3f4f6;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .filters input {
            flex: 1;
            min-width: 200px;
        }
        
        .filters button {
            cursor: pointer;
            background: #3b82f6;
            border-color: #3b82f6;
            transition: background 0.2s;
        }
        
        .filters button:hover {
            background: #2563eb;
        }
        
        table {
            width: 100%;
            background: #1f2937;
            border-radius: 8px;
            overflow: hidden;
            border-collapse: collapse;
        }
        
        th {
            background: #111827;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            font-size: 14px;
            color: #9ca3af;
            border-bottom: 1px solid #374151;
        }
        
        td {
            padding: 12px;
            border-bottom: 1px solid #374151;
        }
        
        tr:hover {
            background: #263345;
        }
        
        .progress-bar {
            width: 100px;
            height: 20px;
            background: #374151;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6 0%, #22c55e 100%);
            transition: width 0.3s ease;
        }
        
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        
        .positive {
            color: #22c55e;
        }
        
        .negative {
            color: #ef4444;
        }
        
        a {
            color: #3b82f6;
            text-decoration: none;
            margin-right: 10px;
        }
        
        a:hover {
            color: #60a5fa;
        }
        
        .alert {
            padding: 16px;
            background: #065f46;
            border: 1px solid #10b981;
            border-radius: 8px;
            color: #d1fae5;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .milestone-alert {
            background: #1e3a8a;
            border-color: #3b82f6;
            color: #dbeafe;
        }
        
        .new-token {
            animation: flashGreen 3s ease;
        }
        
        .milestone-flash {
            animation: flashBlue 3s ease;
        }
        
        @keyframes flashGreen {
            0% { background: #065f46; }
            20% { background: #065f46; }
            100% { background: transparent; }
        }
        
        @keyframes flashBlue {
            0% { background: #1e3a8a; }
            20% { background: #1e3a8a; }
            100% { background: transparent; }
        }
        
        .high-score-token {
            background: rgba(34, 197, 94, 0.1);
        }
        
        /* NEW: Scoring styles */
        .score-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
            min-width: 60px;
            text-align: center;
        }
        
        .score-excellent { background: #22c55e; color: white; }
        .score-good { background: #3b82f6; color: white; }
        .score-average { background: #f59e0b; color: white; }
        .score-poor { background: #ef4444; color: white; }
        
        .score-breakdown {
            display: none;
            position: absolute;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 12px;
            z-index: 1000;
            min-width: 250px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        .score-badge:hover + .score-breakdown,
        .score-breakdown:hover {
            display: block;
        }
        
        .score-component {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 12px;
        }
        
        .score-bar {
            width: 100%;
            height: 8px;
            background: #374151;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }
        
        .score-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444 0%, #f59e0b 40%, #3b82f6 70%, #22c55e 100%);
            transition: width 0.3s ease;
        }
        
        /* High score alert animation */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .high-score-alert {
            animation: pulse 2s infinite;
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }
        
        /* Score history chart */
        .score-history {
            width: 100%;
            height: 60px;
            margin-top: 8px;
        }
        
        /* Sort indicator */
        .sortable {
            cursor: pointer;
            user-select: none;
        }
        
        .sortable:after {
            content: ' â†•';
            opacity: 0.3;
        }
        
        .sortable.asc:after {
            content: ' â†‘';
            opacity: 1;
        }
        
        .sortable.desc:after {
            content: ' â†“';
            opacity: 1;
        }
        
        /* Token info styling for missing images */
        .token-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .token-info img {
            border-radius: 50%;
            object-fit: cover;
        }
        
        .token-info > div {
            display: flex;
            flex-direction: column;
        }
        
        .token-symbol {
            font-weight: bold;
            font-size: 14px;
        }
        
        .token-name {
            font-size: 12px;
            color: #9ca3af;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸš€ Pump.fun Token Monitor V2.1</h1>
        <div class="stats" id="stats">
            <div class="stat-item">
                <span class="stat-label">Active Tokens:</span>
                <span class="stat-value" id="activeCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Total Volume 24h:</span>
                <span class="stat-value" id="volumeTotal">$0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">High Score Tokens:</span>
                <span class="stat-value" id="highScoreCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">SOL Price:</span>
                <span class="stat-value" id="solPrice">$-</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Connected:</span>
                <span class="stat-value" id="connectionStatus">ðŸ”´</span>
            </div>
        </div>
    </div>

    <!-- NEW: High score alerts -->
    <div id="alertsContainer" style="margin: 20px; display: none;">
        <div class="alert high-score-alert" id="highScoreAlert">
            ðŸ”¥ <strong>HIGH SCORE ALERT!</strong> <span id="alertMessage"></span>
        </div>
    </div>

    <!-- NEW: Milestone notifications -->
    <div id="milestoneContainer" style="margin: 20px; display: none;">
        <div class="alert milestone-alert" id="milestoneAlert">
            ðŸŽ¯ <strong>MILESTONE!</strong> <span id="milestoneMessage"></span>
        </div>
    </div>

    <div class="container">
        <div class="filters">
            <input type="text" id="searchInput" placeholder="Search by symbol, name, or address...">
            <select id="mcapFilter">
                <option value="all">All Market Caps</option>
                <option value="15-30">$15k - $30k</option>
                <option value="30-50">$30k - $50k</option>
                <option value="50-100">$50k - $100k</option>
                <option value="100+">$100k+</option>
            </select>
            <select id="scoreFilter">
                <option value="all">All Scores</option>
                <option value="800+">Excellent (800+)</option>
                <option value="600-799">Good (600-799)</option>
                <option value="400-599">Average (400-599)</option>
                <option value="0-399">Poor (0-399)</option>
            </select>
            <button id="refreshBtn">ðŸ”„ Refresh</button>
        </div>

        <table>
            <thead>
                <tr>
                    <th>Token</th>
                    <th class="sortable" data-sort="score">Score</th>
                    <th class="sortable" data-sort="mcap">Market Cap</th>
                    <th class="sortable" data-sort="price">Price</th>
                    <th class="sortable" data-sort="liquidity">Liquidity</th>
                    <th class="sortable" data-sort="progress">Progress</th>
                    <th class="sortable" data-sort="change24h">24h Change</th>
                    <th class="sortable" data-sort="holders">Holders</th>
                    <th class="sortable" data-sort="age">Age</th>
                    <th>Links</th>
                </tr>
            </thead>
            <tbody id="tokenTableBody">
                <!-- Tokens will be inserted here -->
            </tbody>
        </table>
    </div>

    <script>
        // Enhanced dashboard with scoring
        class TokenDashboard {
            constructor() {
                this.ws = null;
                this.tokens = new Map();
                this.sortField = 'score';
                this.sortDirection = 'desc';
                this.highScoreThreshold = 800;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 10;
                this.reconnectDelay = 1000; // Start with 1 second
                this.init();
            }

            init() {
                this.connectWebSocket();
                this.setupEventListeners();
                this.startUpdateTimer();
            }

            connectWebSocket() {
                const wsUrl = `ws://${window.location.hostname}:8080`;
                
                try {
                    this.ws = new WebSocket(wsUrl);

                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        document.getElementById('connectionStatus').textContent = 'ðŸŸ¢';
                        this.reconnectAttempts = 0;
                        this.reconnectDelay = 1000;
                        this.ws.send(JSON.stringify({ type: 'subscribe', channel: 'all' }));
                    };

                    this.ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleMessage(message);
                        } catch (error) {
                            console.error('Error processing WebSocket message:', error);
                            console.error('Raw message:', event.data);
                        }
                    };

                    this.ws.onclose = (event) => {
                        console.log('WebSocket closed:', event.code, event.reason);
                        document.getElementById('connectionStatus').textContent = 'ðŸ”´';
                        this.handleReconnect();
                    };

                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        document.getElementById('connectionStatus').textContent = 'ðŸ”´';
                    };
                } catch (error) {
                    console.error('Failed to create WebSocket:', error);
                    this.handleReconnect();
                }
            }

            handleReconnect() {
                if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                    console.error('Max reconnection attempts reached');
                    document.getElementById('connectionStatus').textContent = 'âŒ';
                    return;
                }

                this.reconnectAttempts++;
                const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1), 30000);
                
                console.log(`Reconnecting in ${delay/1000} seconds... (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                
                setTimeout(() => {
                    this.connectWebSocket();
                }, delay);
            }

            handleMessage(message) {
                // Different message types have different structures
                // Some have data in message.data, others have it directly on message
                const messageData = message.data || message;
                console.log('Received message:', message.type, messageData);
                
                switch (message.type) {
                    case 'tokens':
                        this.updateTokens(messageData);
                        break;
                    case 'new_token':
                        this.addToken(messageData);
                        break;
                    case 'price_update':
                        // Price updates are just notifications - actual token updates come via 'token_update'
                        console.log(`Price update notification: ${message.count || messageData.count || 0} tokens updated`);
                        // The websocket.ts sends count directly on the message, not in data
                        break;
                    case 'token_update':
                        // This is the actual token data update
                        this.updateSingleToken(messageData);
                        break;
                    case 'milestone':
                        // Handle milestone achievements
                        this.handleMilestone(messageData);
                        break;
                    case 'stats':
                        // Handle server stats
                        this.handleStats(messageData);
                        break;
                    case 'high_score_alert':
                        this.showHighScoreAlert(messageData);
                        break;
                    case 'score_update':
                        this.updateTokenScore(messageData);
                        break;
                    default:
                        console.log('Unknown message type:', message.type);
                }
            }

            // FIX: Add the missing updatePrices method with better error handling
            updatePrices(priceData) {
                if (!priceData) {
                    console.warn('updatePrices called with undefined data');
                    return;
                }
                
                // Handle price updates for multiple tokens
                if (Array.isArray(priceData)) {
                    priceData.forEach(update => {
                        if (!update || !update.address) {
                            console.warn('Invalid price update:', update);
                            return;
                        }
                        const token = this.tokens.get(update.address);
                        if (token) {
                            // Ensure price is a number
                            token.current_price = this.ensureNumber(update.price);
                            token.price_change_24h = this.ensureNumber(update.price_change_24h);
                        }
                    });
                } else if (priceData && priceData.address) {
                    // Handle single token price update
                    const token = this.tokens.get(priceData.address);
                    if (token) {
                        token.current_price = this.ensureNumber(priceData.price);
                        token.price_change_24h = this.ensureNumber(priceData.price_change_24h);
                    }
                } else {
                    console.warn('Invalid price data structure:', priceData);
                }
                this.render();
            }

            // Handle individual token updates from WebSocket
            updateSingleToken(tokenData) {
                if (!tokenData || !tokenData.address) {
                    console.warn('Invalid token update:', tokenData);
                    return;
                }
                
                // Ensure all numeric fields are actually numbers
                tokenData.current_price = this.ensureNumber(tokenData.current_price);
                tokenData.current_mcap = this.ensureNumber(tokenData.current_mcap);
                tokenData.current_liquidity = this.ensureNumber(tokenData.current_liquidity);
                tokenData.bonding_progress = this.ensureNumber(tokenData.bonding_progress || tokenData.progress);
                tokenData.progress = this.ensureNumber(tokenData.progress || tokenData.bonding_progress);
                tokenData.price_change_24h = this.ensureNumber(tokenData.price_change_24h);
                tokenData.price_change_1h = this.ensureNumber(tokenData.price_change_1h);
                tokenData.volume_24h = this.ensureNumber(tokenData.volume_24h);
                tokenData.trade_count_24h = this.ensureNumber(tokenData.trade_count_24h);
                tokenData.holder_count = this.ensureNumber(tokenData.holder_count);
                tokenData.score = this.ensureNumber(tokenData.score);
                
                // Update or add the token
                this.tokens.set(tokenData.address, tokenData);
                this.render();
                this.updateStats();
            }

            // FIX: Ensure numeric values
            ensureNumber(value) {
                if (typeof value === 'number') return value;
                if (typeof value === 'string') return parseFloat(value) || 0;
                return 0;
            }

            updateTokens(tokens) {
                this.tokens.clear();
                tokens.forEach(token => {
                    // Ensure all numeric fields are actually numbers
                    token.current_price = this.ensureNumber(token.current_price);
                    token.current_mcap = this.ensureNumber(token.current_mcap);
                    token.current_liquidity = this.ensureNumber(token.current_liquidity);
                    token.progress = this.ensureNumber(token.progress || token.bonding_progress);
                    token.bonding_progress = this.ensureNumber(token.bonding_progress || token.progress);
                    token.price_change_24h = this.ensureNumber(token.price_change_24h);
                    token.holder_count = this.ensureNumber(token.holder_count);
                    token.score = this.ensureNumber(token.score);
                    token.volume_24h = this.ensureNumber(token.volume_24h);
                    
                    this.tokens.set(token.address, token);
                });
                
                // Subscribe to top tokens for real-time updates
                this.subscribeToTopTokens();
                
                this.render();
                this.updateStats();
            }

            // Subscribe to top tokens for real-time updates
            subscribeToTopTokens() {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
                
                // Get top 20 tokens by market cap
                const topTokens = Array.from(this.tokens.values())
                    .sort((a, b) => (b.current_mcap || 0) - (a.current_mcap || 0))
                    .slice(0, 20);
                
                // Subscribe to each token
                topTokens.forEach(token => {
                    this.ws.send(JSON.stringify({ 
                        type: 'subscribe_token', 
                        address: token.address 
                    }));
                });
                
                console.log(`Subscribed to ${topTokens.length} top tokens for real-time updates`);
            }

            addToken(token) {
                // Ensure all numeric fields are actually numbers
                token.current_price = this.ensureNumber(token.current_price);
                token.current_mcap = this.ensureNumber(token.current_mcap);
                token.current_liquidity = this.ensureNumber(token.current_liquidity);
                token.progress = this.ensureNumber(token.progress || token.bonding_progress);
                token.bonding_progress = this.ensureNumber(token.bonding_progress || token.progress);
                token.price_change_24h = this.ensureNumber(token.price_change_24h);
                token.holder_count = this.ensureNumber(token.holder_count);
                token.score = this.ensureNumber(token.score);
                token.volume_24h = this.ensureNumber(token.volume_24h);
                
                this.tokens.set(token.address, token);
                this.render();
                
                // Flash animation for new token
                setTimeout(() => {
                    const row = document.querySelector(`tr[data-address="${token.address}"]`);
                    if (row) {
                        row.classList.add('new-token');
                        setTimeout(() => row.classList.remove('new-token'), 3000);
                    }
                }, 100);
            }

            updateTokenScore(data) {
                const token = this.tokens.get(data.token);
                if (token) {
                    token.score = this.ensureNumber(data.score);
                    token.score_breakdown = data.breakdown;
                    this.render();
                }
            }

            showHighScoreAlert(data) {
                const alertContainer = document.getElementById('alertsContainer');
                const alertMessage = document.getElementById('alertMessage');
                
                alertMessage.textContent = `${data.token.symbol || 'Unknown'} scored ${data.score}/1000!`;
                alertContainer.style.display = 'block';
                
                setTimeout(() => {
                    alertContainer.style.display = 'none';
                }, 10000);
            }

            // Handle milestone notifications
            handleMilestone(data) {
                const token = this.tokens.get(data.token);
                if (token) {
                    // Update progress if different
                    if (token.progress !== data.progress) {
                        token.progress = data.progress;
                        token.bonding_progress = data.progress;
                        this.render();
                    }
                }
                
                // Show notification for significant milestones
                if (data.milestone >= 50) {
                    this.showMilestoneNotification(data);
                }
            }

            // Show milestone notifications
            showMilestoneNotification(data) {
                const token = this.tokens.get(data.token);
                if (!token) return;
                
                const milestoneContainer = document.getElementById('milestoneContainer');
                const milestoneMessage = document.getElementById('milestoneMessage');
                
                const emoji = data.milestone >= 75 ? 'ðŸš€' : data.milestone >= 50 ? 'ðŸ”¥' : data.milestone >= 25 ? 'â­' : 'âœ¨';
                milestoneMessage.textContent = `${emoji} ${token.symbol || 'Token'} reached ${data.milestone}% bonding curve progress!`;
                milestoneContainer.style.display = 'block';
                
                // Also flash the token row
                const row = document.querySelector(`tr[data-address="${data.token}"]`);
                if (row) {
                    row.classList.add('milestone-flash');
                    setTimeout(() => row.classList.remove('milestone-flash'), 3000);
                }
                
                setTimeout(() => {
                    milestoneContainer.style.display = 'none';
                }, 5000);
            }

            // Handle server stats updates
            handleStats(data) {
                // Update stats display if needed
                if (data.currentSolPrice) {
                    const solPriceElement = document.getElementById('solPrice');
                    if (solPriceElement) {
                        solPriceElement.textContent = `${data.currentSolPrice.toFixed(2)}`;
                    }
                }
                
                // Log stats for debugging
                console.log('Server stats:', {
                    priceUpdates: data.priceUpdates,
                    knownTokens: data.knownTokens,
                    milestonesTracked: data.milestonesTracked,
                    bufferSize: data.priceBufferSize
                });
            }

            getScoreBadgeClass(score) {
                if (score >= 800) return 'score-excellent';
                if (score >= 600) return 'score-good';
                if (score >= 400) return 'score-average';
                return 'score-poor';
            }

            formatScoreBreakdown(breakdown) {
                if (!breakdown) return '';
                
                return `
                    <div class="score-breakdown">
                        <div class="score-component">
                            <span>Technical:</span>
                            <span>${breakdown.technical || 0}/400</span>
                        </div>
                        <div class="score-component">
                            <span>Holders:</span>
                            <span>${breakdown.holders || 0}/200</span>
                        </div>
                        <div class="score-component">
                            <span>Social:</span>
                            <span>${breakdown.social || 0}/200</span>
                        </div>
                        <div class="score-component">
                            <span>Creator:</span>
                            <span>${breakdown.creator || 0}/200</span>
                        </div>
                        <div class="score-component" style="color: #ef4444;">
                            <span>Risk:</span>
                            <span>-${breakdown.risk || 0}</span>
                        </div>
                        <div style="border-top: 1px solid #374151; margin-top: 8px; padding-top: 8px;">
                            <div class="score-component" style="font-weight: bold;">
                                <span>Total:</span>
                                <span>${breakdown.total || 0}/1000</span>
                            </div>
                            <div class="score-bar">
                                <div class="score-fill" style="width: ${(breakdown.total || 0) / 10}%"></div>
                            </div>
                        </div>
                    </div>
                `;
            }

            render() {
                const tbody = document.getElementById('tokenTableBody');
                const tokens = Array.from(this.tokens.values());
                
                // Apply filters
                const filtered = this.applyFilters(tokens);
                
                // Sort
                const sorted = this.sortTokens(filtered);
                
                // Render rows
                tbody.innerHTML = sorted.map(token => {
                    const score = token.score || 0;
                    const scoreClass = this.getScoreBadgeClass(score);
                    const isHighScore = score >= this.highScoreThreshold;
                    
                    return `
                        <tr data-address="${token.address}" class="${isHighScore ? 'high-score-token' : ''}">
                            <td>
                                <div class="token-info">
                                    ${(token.image_uri || token.imageUri) ? `<img src="${this.getImageUrl(token.image_uri || token.imageUri)}" alt="${token.symbol}" width="32" height="32" onerror="this.style.display='none'">` : ''}
                                    <div>
                                        <span class="token-symbol">${token.symbol || 'Unknown'}</span>
                                        <span class="token-name">${token.name || ''}</span>
                                    </div>
                                </div>
                            </td>
                            <td>
                                <div style="position: relative;">
                                    <span class="score-badge ${scoreClass}">${score}</span>
                                    ${this.formatScoreBreakdown(token.score_breakdown)}
                                </div>
                            </td>
                            <td>$${this.formatNumber(token.current_mcap || 0)}</td>
                            <td>$${this.formatPrice(token.current_price || 0)}</td>
                            <td>$${this.formatNumber(token.current_liquidity || 0)}</td>
                            <td>
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${token.bonding_progress || token.progress || 0}%"></div>
                                    <span class="progress-text">${(token.bonding_progress || token.progress || 0).toFixed(1)}%</span>
                                </div>
                            </td>
                            <td class="${token.price_change_24h > 0 ? 'positive' : 'negative'}">
                                ${token.price_change_24h ? (token.price_change_24h > 0 ? '+' : '') + token.price_change_24h.toFixed(1) + '%' : 'N/A'}
                            </td>
                            <td>${token.holder_count || '-'}</td>
                            <td>${this.formatAge(token.created_at)}</td>
                            <td>
                                <a href="https://pump.fun/${token.vanity_id || token.vanityId || token.address}" target="_blank">Pump</a>
                                <a href="token.html?address=${token.address}" target="_blank">Details</a>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            applyFilters(tokens) {
                const searchTerm = document.getElementById('searchInput').value.toLowerCase();
                const mcapFilter = document.getElementById('mcapFilter').value;
                const scoreFilter = document.getElementById('scoreFilter').value;
                
                return tokens.filter(token => {
                    // Search filter
                    if (searchTerm && !this.matchesSearch(token, searchTerm)) {
                        return false;
                    }
                    
                    // Market cap filter
                    if (mcapFilter !== 'all' && !this.matchesMcapFilter(token, mcapFilter)) {
                        return false;
                    }
                    
                    // Score filter
                    if (scoreFilter !== 'all' && !this.matchesScoreFilter(token, scoreFilter)) {
                        return false;
                    }
                    
                    return true;
                });
            }

            matchesScoreFilter(token, filter) {
                const score = token.score || 0;
                switch (filter) {
                    case '800+': return score >= 800;
                    case '600-799': return score >= 600 && score < 800;
                    case '400-599': return score >= 400 && score < 600;
                    case '0-399': return score < 400;
                    default: return true;
                }
            }

            sortTokens(tokens) {
                return tokens.sort((a, b) => {
                    let aVal, bVal;
                    
                    switch (this.sortField) {
                        case 'score':
                            aVal = a.score || 0;
                            bVal = b.score || 0;
                            break;
                        case 'mcap':
                            aVal = a.current_mcap || 0;
                            bVal = b.current_mcap || 0;
                            break;
                        case 'price':
                            aVal = a.current_price || 0;
                            bVal = b.current_price || 0;
                            break;
                        case 'liquidity':
                            aVal = a.current_liquidity || 0;
                            bVal = b.current_liquidity || 0;
                            break;
                        case 'progress':
                            aVal = a.bonding_progress || a.progress || 0;
                            bVal = b.bonding_progress || b.progress || 0;
                            break;
                        case 'change24h':
                            aVal = a.price_change_24h || 0;
                            bVal = b.price_change_24h || 0;
                            break;
                        case 'holders':
                            aVal = a.holder_count || 0;
                            bVal = b.holder_count || 0;
                            break;
                        case 'age':
                            aVal = new Date(a.created_at).getTime();
                            bVal = new Date(b.created_at).getTime();
                            break;
                        default:
                            aVal = a[this.sortField] || 0;
                            bVal = b[this.sortField] || 0;
                    }
                    
                    if (this.sortDirection === 'asc') {
                        return aVal - bVal;
                    } else {
                        return bVal - aVal;
                    }
                });
            }

            updateStats() {
                const tokens = Array.from(this.tokens.values());
                const highScoreTokens = tokens.filter(t => (t.score || 0) >= this.highScoreThreshold);
                
                document.getElementById('activeCount').textContent = tokens.length;
                document.getElementById('highScoreCount').textContent = highScoreTokens.length;
                
                const totalVolume = tokens.reduce((sum, t) => sum + (t.volume_24h || 0), 0);
                document.getElementById('volumeTotal').textContent = '$' + this.formatNumber(totalVolume);
            }

            setupEventListeners() {
                // Sort headers
                document.querySelectorAll('.sortable').forEach(header => {
                    header.addEventListener('click', (e) => {
                        const field = e.target.dataset.sort;
                        if (this.sortField === field) {
                            this.sortDirection = this.sortDirection === 'desc' ? 'asc' : 'desc';
                        } else {
                            this.sortField = field;
                            this.sortDirection = 'desc';
                        }
                        
                        // Update visual indicators
                        document.querySelectorAll('.sortable').forEach(h => {
                            h.classList.remove('asc', 'desc');
                        });
                        e.target.classList.add(this.sortDirection);
                        
                        this.render();
                    });
                });
                
                // Filters
                ['searchInput', 'mcapFilter', 'scoreFilter'].forEach(id => {
                    document.getElementById(id).addEventListener('change', () => this.render());
                });
                
                document.getElementById('searchInput').addEventListener('keyup', () => this.render());
                
                // Refresh button
                document.getElementById('refreshBtn').addEventListener('click', () => {
                    this.ws.send(JSON.stringify({ type: 'refresh' }));
                });
            }

            startUpdateTimer() {
                setInterval(() => {
                    this.render(); // Re-render to update ages
                }, 30000); // Every 30 seconds
            }

            // Utility functions
            formatNumber(num) {
                if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(2) + 'K';
                return num.toFixed(2);
            }

            // FIX: Handle IPFS image URLs with fallback gateways
            getImageUrl(imageUri) {
                if (!imageUri) return '';
                
                // List of IPFS gateways to try
                const gateways = [
                    'https://gateway.pinata.cloud/ipfs/',
                    'https://cloudflare-ipfs.com/ipfs/',
                    'https://ipfs.filebase.io/ipfs/',
                    'https://w3s.link/ipfs/'
                ];
                
                // If it's already a full URL, return as is
                if (imageUri.startsWith('http://') || imageUri.startsWith('https://')) {
                    // Replace ipfs.io with a working gateway if needed
                    if (imageUri.includes('ipfs.io/ipfs/')) {
                        const hash = imageUri.split('ipfs.io/ipfs/')[1];
                        return gateways[0] + hash;
                    }
                    return imageUri;
                }
                
                // If it's an IPFS hash, use a gateway
                if (imageUri.startsWith('ipfs://')) {
                    const hash = imageUri.replace('ipfs://', '');
                    return gateways[0] + hash;
                }
                
                // Assume it's a raw hash
                return gateways[0] + imageUri;
            }

            // FIX: Ensure price is a number before calling toFixed
            formatPrice(price) {
                // Convert to number if it's not already
                const numPrice = this.ensureNumber(price);
                
                if (numPrice < 0.00001) return numPrice.toExponential(2);
                if (numPrice < 0.01) return numPrice.toFixed(6);
                if (numPrice < 1) return numPrice.toFixed(4);
                return numPrice.toFixed(2);
            }

            formatAge(createdAt) {
                const age = Date.now() - new Date(createdAt).getTime();
                const hours = Math.floor(age / (1000 * 60 * 60));
                if (hours < 1) return Math.floor(age / (1000 * 60)) + 'm';
                if (hours < 24) return hours + 'h';
                return Math.floor(hours / 24) + 'd';
            }

            matchesSearch(token, searchTerm) {
                return (
                    (token.symbol && token.symbol.toLowerCase().includes(searchTerm)) ||
                    (token.name && token.name.toLowerCase().includes(searchTerm)) ||
                    token.address.toLowerCase().includes(searchTerm)
                );
            }

            matchesMcapFilter(token, filter) {
                const mcap = token.current_mcap || 0;
                switch (filter) {
                    case '15-30': return mcap >= 15000 && mcap < 30000;
                    case '30-50': return mcap >= 30000 && mcap < 50000;
                    case '50-100': return mcap >= 50000 && mcap < 100000;
                    case '100+': return mcap >= 100000;
                    default: return true;
                }
            }
        }

        // Initialize dashboard
        const dashboard = new TokenDashboard();
    </script>
</body>
</html>