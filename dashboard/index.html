<!-- Updates to add to dashboard/index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Pump.fun Monitor Dashboard</title>
    <style>
        /* Existing styles... */
        
        /* NEW: Scoring styles */
        .score-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
            min-width: 60px;
            text-align: center;
        }
        
        .score-excellent { background: #22c55e; color: white; }
        .score-good { background: #3b82f6; color: white; }
        .score-average { background: #f59e0b; color: white; }
        .score-poor { background: #ef4444; color: white; }
        
        .score-breakdown {
            display: none;
            position: absolute;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 12px;
            z-index: 1000;
            min-width: 250px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        .score-badge:hover + .score-breakdown,
        .score-breakdown:hover {
            display: block;
        }
        
        .score-component {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            font-size: 12px;
        }
        
        .score-bar {
            width: 100%;
            height: 8px;
            background: #374151;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 4px;
        }
        
        .score-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444 0%, #f59e0b 40%, #3b82f6 70%, #22c55e 100%);
            transition: width 0.3s ease;
        }
        
        /* High score alert animation */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .high-score-alert {
            animation: pulse 2s infinite;
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }
        
        /* Score history chart */
        .score-history {
            width: 100%;
            height: 60px;
            margin-top: 8px;
        }
        
        /* Sort indicator */
        .sortable {
            cursor: pointer;
            user-select: none;
        }
        
        .sortable:after {
            content: ' â†•';
            opacity: 0.3;
        }
        
        .sortable.asc:after {
            content: ' â†‘';
            opacity: 1;
        }
        
        .sortable.desc:after {
            content: ' â†“';
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸš€ Pump.fun Token Monitor V2.1</h1>
        <div class="stats" id="stats">
            <div class="stat-item">
                <span class="stat-label">Active Tokens:</span>
                <span class="stat-value" id="activeCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Total Volume 24h:</span>
                <span class="stat-value" id="volumeTotal">$0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">High Score Tokens:</span>
                <span class="stat-value" id="highScoreCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Connected:</span>
                <span class="stat-value" id="connectionStatus">ðŸ”´</span>
            </div>
        </div>
    </div>

    <!-- NEW: High score alerts -->
    <div id="alertsContainer" style="margin: 20px; display: none;">
        <div class="alert high-score-alert" id="highScoreAlert">
            ðŸ”¥ <strong>HIGH SCORE ALERT!</strong> <span id="alertMessage"></span>
        </div>
    </div>

    <div class="container">
        <div class="filters">
            <input type="text" id="searchInput" placeholder="Search by symbol, name, or address...">
            <select id="mcapFilter">
                <option value="all">All Market Caps</option>
                <option value="15-30">$15k - $30k</option>
                <option value="30-50">$30k - $50k</option>
                <option value="50-100">$50k - $100k</option>
                <option value="100+">$100k+</option>
            </select>
            <select id="scoreFilter">
                <option value="all">All Scores</option>
                <option value="800+">Excellent (800+)</option>
                <option value="600-799">Good (600-799)</option>
                <option value="400-599">Average (400-599)</option>
                <option value="0-399">Poor (0-399)</option>
            </select>
            <button id="refreshBtn">ðŸ”„ Refresh</button>
        </div>

        <table>
            <thead>
                <tr>
                    <th>Token</th>
                    <th class="sortable" data-sort="score">Score</th>
                    <th class="sortable" data-sort="mcap">Market Cap</th>
                    <th class="sortable" data-sort="price">Price</th>
                    <th class="sortable" data-sort="liquidity">Liquidity</th>
                    <th class="sortable" data-sort="progress">Progress</th>
                    <th class="sortable" data-sort="change24h">24h Change</th>
                    <th class="sortable" data-sort="holders">Holders</th>
                    <th class="sortable" data-sort="age">Age</th>
                    <th>Links</th>
                </tr>
            </thead>
            <tbody id="tokenTableBody">
                <!-- Tokens will be inserted here -->
            </tbody>
        </table>
    </div>

    <script>
        // Enhanced dashboard with scoring
        class TokenDashboard {
            constructor() {
                this.ws = null;
                this.tokens = new Map();
                this.sortField = 'score';
                this.sortDirection = 'desc';
                this.highScoreThreshold = 800;
                this.init();
            }

            init() {
                this.connectWebSocket();
                this.setupEventListeners();
                this.startUpdateTimer();
            }

            connectWebSocket() {
                const wsUrl = `ws://${window.location.hostname}:8080`;
                this.ws = new WebSocket(wsUrl);

                this.ws.onopen = () => {
                    console.log('WebSocket connected');
                    document.getElementById('connectionStatus').textContent = 'ðŸŸ¢';
                    this.ws.send(JSON.stringify({ type: 'subscribe', channel: 'all' }));
                };

                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleMessage(message);
                };

                this.ws.onclose = () => {
                    document.getElementById('connectionStatus').textContent = 'ðŸ”´';
                    setTimeout(() => this.connectWebSocket(), 3000);
                };
            }

            handleMessage(message) {
                switch (message.type) {
                    case 'tokens':
                        this.updateTokens(message.data);
                        break;
                    case 'new_token':
                        this.addToken(message.data);
                        break;
                    case 'price_update':
                        this.updatePrices(message.data);
                        break;
                    case 'high_score_alert':
                        this.showHighScoreAlert(message.data);
                        break;
                    case 'score_update':
                        this.updateTokenScore(message.data);
                        break;
                }
            }

            updateTokens(tokens) {
                this.tokens.clear();
                tokens.forEach(token => {
                    this.tokens.set(token.address, token);
                });
                this.render();
                this.updateStats();
            }

            addToken(token) {
                this.tokens.set(token.address, token);
                this.render();
                
                // Flash animation for new token
                setTimeout(() => {
                    const row = document.querySelector(`tr[data-address="${token.address}"]`);
                    if (row) {
                        row.classList.add('new-token');
                        setTimeout(() => row.classList.remove('new-token'), 3000);
                    }
                }, 100);
            }

            updateTokenScore(data) {
                const token = this.tokens.get(data.token);
                if (token) {
                    token.score = data.score;
                    token.score_breakdown = data.breakdown;
                    this.render();
                }
            }

            showHighScoreAlert(data) {
                const alertContainer = document.getElementById('alertsContainer');
                const alertMessage = document.getElementById('alertMessage');
                
                alertMessage.textContent = `${data.token.symbol || 'Unknown'} scored ${data.score}/1000!`;
                alertContainer.style.display = 'block';
                
                setTimeout(() => {
                    alertContainer.style.display = 'none';
                }, 10000);
            }

            getScoreBadgeClass(score) {
                if (score >= 800) return 'score-excellent';
                if (score >= 600) return 'score-good';
                if (score >= 400) return 'score-average';
                return 'score-poor';
            }

            formatScoreBreakdown(breakdown) {
                if (!breakdown) return '';
                
                return `
                    <div class="score-breakdown">
                        <div class="score-component">
                            <span>Technical:</span>
                            <span>${breakdown.technical || 0}/400</span>
                        </div>
                        <div class="score-component">
                            <span>Holders:</span>
                            <span>${breakdown.holders || 0}/200</span>
                        </div>
                        <div class="score-component">
                            <span>Social:</span>
                            <span>${breakdown.social || 0}/200</span>
                        </div>
                        <div class="score-component">
                            <span>Creator:</span>
                            <span>${breakdown.creator || 0}/200</span>
                        </div>
                        <div class="score-component" style="color: #ef4444;">
                            <span>Risk:</span>
                            <span>-${breakdown.risk || 0}</span>
                        </div>
                        <div style="border-top: 1px solid #374151; margin-top: 8px; padding-top: 8px;">
                            <div class="score-component" style="font-weight: bold;">
                                <span>Total:</span>
                                <span>${breakdown.total || 0}/1000</span>
                            </div>
                            <div class="score-bar">
                                <div class="score-fill" style="width: ${(breakdown.total || 0) / 10}%"></div>
                            </div>
                        </div>
                    </div>
                `;
            }

            render() {
                const tbody = document.getElementById('tokenTableBody');
                const tokens = Array.from(this.tokens.values());
                
                // Apply filters
                const filtered = this.applyFilters(tokens);
                
                // Sort
                const sorted = this.sortTokens(filtered);
                
                // Render rows
                tbody.innerHTML = sorted.map(token => {
                    const score = token.score || 0;
                    const scoreClass = this.getScoreBadgeClass(score);
                    const isHighScore = score >= this.highScoreThreshold;
                    
                    return `
                        <tr data-address="${token.address}" class="${isHighScore ? 'high-score-token' : ''}">
                            <td>
                                <div class="token-info">
                                    ${token.image_uri ? `<img src="${token.image_uri}" alt="${token.symbol}">` : ''}
                                    <div>
                                        <span class="token-symbol">${token.symbol || 'Unknown'}</span>
                                        <span class="token-name">${token.name || ''}</span>
                                    </div>
                                </div>
                            </td>
                            <td>
                                <div style="position: relative;">
                                    <span class="score-badge ${scoreClass}">${score}</span>
                                    ${this.formatScoreBreakdown(token.score_breakdown)}
                                </div>
                            </td>
                            <td>$${this.formatNumber(token.current_mcap || 0)}</td>
                            <td>$${this.formatPrice(token.current_price || 0)}</td>
                            <td>$${this.formatNumber(token.current_liquidity || 0)}</td>
                            <td>
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${token.progress || 0}%"></div>
                                    <span class="progress-text">${(token.progress || 0).toFixed(1)}%</span>
                                </div>
                            </td>
                            <td class="${token.price_change_24h > 0 ? 'positive' : 'negative'}">
                                ${token.price_change_24h ? (token.price_change_24h > 0 ? '+' : '') + token.price_change_24h.toFixed(1) + '%' : 'N/A'}
                            </td>
                            <td>${token.holder_count || '-'}</td>
                            <td>${this.formatAge(token.created_at)}</td>
                            <td>
                                <a href="https://pump.fun/${token.vanity_id || token.address}" target="_blank">Pump</a>
                                <a href="token.html?address=${token.address}" target="_blank">Details</a>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            applyFilters(tokens) {
                const searchTerm = document.getElementById('searchInput').value.toLowerCase();
                const mcapFilter = document.getElementById('mcapFilter').value;
                const scoreFilter = document.getElementById('scoreFilter').value;
                
                return tokens.filter(token => {
                    // Search filter
                    if (searchTerm && !this.matchesSearch(token, searchTerm)) {
                        return false;
                    }
                    
                    // Market cap filter
                    if (mcapFilter !== 'all' && !this.matchesMcapFilter(token, mcapFilter)) {
                        return false;
                    }
                    
                    // Score filter
                    if (scoreFilter !== 'all' && !this.matchesScoreFilter(token, scoreFilter)) {
                        return false;
                    }
                    
                    return true;
                });
            }

            matchesScoreFilter(token, filter) {
                const score = token.score || 0;
                switch (filter) {
                    case '800+': return score >= 800;
                    case '600-799': return score >= 600 && score < 800;
                    case '400-599': return score >= 400 && score < 600;
                    case '0-399': return score < 400;
                    default: return true;
                }
            }

            sortTokens(tokens) {
                return tokens.sort((a, b) => {
                    let aVal, bVal;
                    
                    switch (this.sortField) {
                        case 'score':
                            aVal = a.score || 0;
                            bVal = b.score || 0;
                            break;
                        case 'mcap':
                            aVal = a.current_mcap || 0;
                            bVal = b.current_mcap || 0;
                            break;
                        case 'holders':
                            aVal = a.holder_count || 0;
                            bVal = b.holder_count || 0;
                            break;
                        default:
                            aVal = a[this.sortField] || 0;
                            bVal = b[this.sortField] || 0;
                    }
                    
                    if (this.sortDirection === 'asc') {
                        return aVal - bVal;
                    } else {
                        return bVal - aVal;
                    }
                });
            }

            updateStats() {
                const tokens = Array.from(this.tokens.values());
                const highScoreTokens = tokens.filter(t => (t.score || 0) >= this.highScoreThreshold);
                
                document.getElementById('activeCount').textContent = tokens.length;
                document.getElementById('highScoreCount').textContent = highScoreTokens.length;
                
                const totalVolume = tokens.reduce((sum, t) => sum + (t.volume_24h || 0), 0);
                document.getElementById('volumeTotal').textContent = '$' + this.formatNumber(totalVolume);
            }

            setupEventListeners() {
                // Sort headers
                document.querySelectorAll('.sortable').forEach(header => {
                    header.addEventListener('click', (e) => {
                        const field = e.target.dataset.sort;
                        if (this.sortField === field) {
                            this.sortDirection = this.sortDirection === 'desc' ? 'asc' : 'desc';
                        } else {
                            this.sortField = field;
                            this.sortDirection = 'desc';
                        }
                        
                        // Update visual indicators
                        document.querySelectorAll('.sortable').forEach(h => {
                            h.classList.remove('asc', 'desc');
                        });
                        e.target.classList.add(this.sortDirection);
                        
                        this.render();
                    });
                });
                
                // Filters
                ['searchInput', 'mcapFilter', 'scoreFilter'].forEach(id => {
                    document.getElementById(id).addEventListener('change', () => this.render());
                });
                
                document.getElementById('searchInput').addEventListener('keyup', () => this.render());
                
                // Refresh button
                document.getElementById('refreshBtn').addEventListener('click', () => {
                    this.ws.send(JSON.stringify({ type: 'refresh' }));
                });
            }

            startUpdateTimer() {
                setInterval(() => {
                    this.render(); // Re-render to update ages
                }, 30000); // Every 30 seconds
            }

            // Utility functions
            formatNumber(num) {
                if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
                if (num >= 1000) return (num / 1000).toFixed(2) + 'K';
                return num.toFixed(2);
            }

            formatPrice(price) {
                if (price < 0.00001) return price.toExponential(2);
                if (price < 0.01) return price.toFixed(6);
                if (price < 1) return price.toFixed(4);
                return price.toFixed(2);
            }

            formatAge(createdAt) {
                const age = Date.now() - new Date(createdAt).getTime();
                const hours = Math.floor(age / (1000 * 60 * 60));
                if (hours < 1) return Math.floor(age / (1000 * 60)) + 'm';
                if (hours < 24) return hours + 'h';
                return Math.floor(hours / 24) + 'd';
            }

            matchesSearch(token, searchTerm) {
                return (
                    (token.symbol && token.symbol.toLowerCase().includes(searchTerm)) ||
                    (token.name && token.name.toLowerCase().includes(searchTerm)) ||
                    token.address.toLowerCase().includes(searchTerm)
                );
            }

            matchesMcapFilter(token, filter) {
                const mcap = token.current_mcap || 0;
                switch (filter) {
                    case '15-30': return mcap >= 15000 && mcap < 30000;
                    case '30-50': return mcap >= 30000 && mcap < 50000;
                    case '50-100': return mcap >= 50000 && mcap < 100000;
                    case '100+': return mcap >= 100000;
                    default: return true;
                }
            }
        }

        // Initialize dashboard
        const dashboard = new TokenDashboard();
    </script>
</body>
</html>